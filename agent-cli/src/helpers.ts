// ─── Pure helper functions extracted for testability ─────────────────────────

import * as fs from "node:fs";
import * as path from "node:path";
import type { Registry } from "./types.js";

// ─── Types ───────────────────────────────────────────────────────────────────

export interface ResolvedEntry {
  key: string;
  srcPath: string;
  destFolder: string;
}

// ─── Functions ───────────────────────────────────────────────────────────────

/**
 * Resolve the output path for agent instructions based on --format flag.
 */
export function resolveAgentOutputPath(
  format: string | undefined,
  manifestDefault?: string,
): string {
  switch (format) {
    case "copilot":
      return ".github/copilot-instructions.md";
    case "cursor":
      return ".cursorrules";
    case "claude":
      return "CLAUDE.md";
    default:
      return manifestDefault ?? "agent.md";
  }
}

/**
 * Compose multiple agent instruction sections into a single file.
 * Adds a generation header and separator between sections.
 */
export function composeAgentFile(sections: string[]): string {
  const header = [
    "<!-- Auto-generated by agent-cli. Do not edit manually. -->",
    "<!-- Run `agent install` to regenerate. -->",
    "",
  ];

  if (sections.length === 1) {
    return [...header, sections[0], ""].join("\n");
  }

  const body = sections.join("\n\n---\n\n");
  return [...header, body, ""].join("\n");
}

/**
 * Resolve include keys into source paths and destination folder names,
 * separating skills from agent instructions based on category type.
 */
export function resolveIncludes(
  includes: string[],
  registry: Registry,
): { skills: ResolvedEntry[]; agents: ResolvedEntry[] } {
  const skills: ResolvedEntry[] = [];
  const agents: ResolvedEntry[] = [];

  for (const entry of includes) {
    const [catKey, skillKey] = entry.split("/");
    const cat = registry.categories[catKey];
    if (!cat) {
      console.warn(`  ⚠  Unknown category "${catKey}" — skipping "${entry}"`);
      continue;
    }

    const folder = cat.skills[skillKey];
    if (!folder) {
      console.warn(`  ⚠  Unknown entry "${skillKey}" in "${catKey}" — skipping`);
      continue;
    }

    const resolved: ResolvedEntry = {
      key: entry,
      srcPath: path.join(cat.path, folder),
      destFolder: folder,
    };

    if (cat.type === "agent") {
      agents.push(resolved);
    } else {
      skills.push(resolved);
    }
  }

  return { skills, agents };
}

/**
 * Find the agent.md file inside a directory.
 */
export function findAgentFile(dir: string): string | null {
  if (!fs.existsSync(dir)) return null;

  // Look for agent.md (primary) or any .md file
  const agentMd = path.join(dir, "agent.md");
  if (fs.existsSync(agentMd)) return agentMd;

  // Fallback: first .md file found
  const entries = fs.readdirSync(dir);
  const md = entries.find((e) => e.endsWith(".md"));
  return md ? path.join(dir, md) : null;
}

/**
 * Find the skill.md file inside a directory.
 */
export function findSkillFile(dir: string): string | null {
  if (!fs.existsSync(dir)) return null;

  // Look for skill.md (primary) or any .md file
  const skillMd = path.join(dir, "skill.md");
  if (fs.existsSync(skillMd)) return skillMd;

  // Fallback: first .md file found
  const entries = fs.readdirSync(dir);
  const md = entries.find((e) => e.endsWith(".md"));
  return md ? path.join(dir, md) : null;
}

/**
 * Recursively compare two directories for differences.
 */
export function hasDifferences(srcDir: string, destDir: string): boolean {
  if (!fs.existsSync(destDir)) return true;

  const srcEntries = fs.readdirSync(srcDir, { withFileTypes: true });

  for (const entry of srcEntries) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      if (hasDifferences(srcPath, destPath)) return true;
    } else {
      if (!fs.existsSync(destPath)) return true;
      const srcContent = fs.readFileSync(srcPath);
      const destContent = fs.readFileSync(destPath);
      if (!srcContent.equals(destContent)) return true;
    }
  }

  return false;
}

/**
 * Check whether a path is covered by the lines in a .gitignore file.
 * Returns the list of paths that are NOT ignored.
 */
export function findMissingGitignoreEntries(
  pathsToCheck: string[],
  gitignoreContent: string | null,
): string[] {
  const missing: string[] = [];

  if (gitignoreContent === null) {
    // No .gitignore exists — everything is missing
    return pathsToCheck.map((p) => p.replace(/^\.\//, ""));
  }

  const lines = gitignoreContent.split("\n").map((l) => l.trim());

  for (const p of pathsToCheck) {
    const normalised = p.replace(/^\.\//, "");
    const isIgnored = lines.some((line) => {
      if (line.startsWith("#") || line === "") return false;
      const clean = line.replace(/^\//, "").replace(/\/+$/, "");
      return clean === normalised || clean === normalised.replace(/\/+$/, "");
    });

    if (!isIgnored) {
      missing.push(normalised);
    }
  }

  return missing;
}

/**
 * Generate a README.md index content for the skills output directory.
 */
export function generateSkillsIndexContent(resolved: ResolvedEntry[]): string {
  const lines: string[] = [
    "# Installed Skills",
    "",
    "> Auto-generated by `agent install`. Do not edit manually.",
    "",
  ];

  // Group by category
  const grouped = new Map<string, ResolvedEntry[]>();
  for (const r of resolved) {
    const cat = r.key.split("/")[0];
    const list = grouped.get(cat) ?? [];
    list.push(r);
    grouped.set(cat, list);
  }

  for (const [cat, skills] of grouped) {
    lines.push(`## ${cat}`);
    lines.push("");
    for (const s of skills) {
      lines.push(`- [${s.destFolder}](./${s.destFolder}/skill.md)`);
    }
    lines.push("");
  }

  return lines.join("\n");
}
