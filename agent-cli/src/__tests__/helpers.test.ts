import { describe, it, beforeEach, afterEach } from "node:test";
import * as assert from "node:assert/strict";
import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";

import {
  resolveAgentOutputPath,
  composeAgentFile,
  resolveIncludes,
  findAgentFile,
  findSkillFile,
  hasDifferences,
  findMissingGitignoreEntries,
  generateSkillsIndexContent,
} from "../helpers.js";

import type { Registry } from "../types.js";

// ─── resolveAgentOutputPath ──────────────────────────────────────────────────

describe("resolveAgentOutputPath", () => {
  it("returns copilot path for 'copilot' format", () => {
    assert.equal(
      resolveAgentOutputPath("copilot"),
      ".github/copilot-instructions.md",
    );
  });

  it("returns cursor path for 'cursor' format", () => {
    assert.equal(resolveAgentOutputPath("cursor"), ".cursorrules");
  });

  it("returns claude path for 'claude' format", () => {
    assert.equal(resolveAgentOutputPath("claude"), "CLAUDE.md");
  });

  it("returns manifest default when format is undefined", () => {
    assert.equal(resolveAgentOutputPath(undefined, "custom.md"), "custom.md");
  });

  it("returns 'agent.md' when both format and default are undefined", () => {
    assert.equal(resolveAgentOutputPath(undefined), "agent.md");
  });

  it("returns 'agent.md' for unknown format without manifest default", () => {
    assert.equal(resolveAgentOutputPath("unknown-format"), "agent.md");
  });

  it("prefers manifest default over agent.md for unknown format", () => {
    assert.equal(
      resolveAgentOutputPath("unknown-format", "instructions.md"),
      "instructions.md",
    );
  });
});

// ─── composeAgentFile ────────────────────────────────────────────────────────

describe("composeAgentFile", () => {
  const HEADER_LINE_1 =
    "<!-- Auto-generated by agent-cli. Do not edit manually. -->";
  const HEADER_LINE_2 = "<!-- Run `agent install` to regenerate. -->";

  it("includes generation header", () => {
    const result = composeAgentFile(["# Hello"]);
    assert.ok(result.includes(HEADER_LINE_1));
    assert.ok(result.includes(HEADER_LINE_2));
  });

  it("outputs single section without separator", () => {
    const result = composeAgentFile(["# Section One"]);
    assert.ok(result.includes("# Section One"));
    assert.ok(!result.includes("---"));
  });

  it("separates multiple sections with ---", () => {
    const result = composeAgentFile(["# One", "# Two"]);
    assert.ok(result.includes("# One"));
    assert.ok(result.includes("---"));
    assert.ok(result.includes("# Two"));
  });

  it("ends with a trailing newline", () => {
    const result = composeAgentFile(["content"]);
    assert.ok(result.endsWith("\n"));
  });

  it("preserves section content exactly", () => {
    const section = "# Title\n\nSome **bold** text\n\n- list item";
    const result = composeAgentFile([section]);
    assert.ok(result.includes(section));
  });

  it("handles three sections with two separators", () => {
    const result = composeAgentFile(["A", "B", "C"]);
    const separatorCount = (result.match(/---/g) ?? []).length;
    assert.equal(separatorCount, 2);
  });
});

// ─── resolveIncludes ─────────────────────────────────────────────────────────

describe("resolveIncludes", () => {
  const registry: Registry = {
    version: "1.0.0",
    categories: {
      development: {
        name: "Development",
        description: "Dev skills",
        path: "development/skills",
        type: "skill",
        skills: {
          architecture: "01-architecture",
          git: "02-git",
        },
      },
      agents: {
        name: "Agent Instructions",
        description: "Agent configs",
        path: "agents/instructions",
        type: "agent",
        skills: {
          nextjs: "nextjs-fullstack",
          typescript: "typescript-general",
        },
      },
      legacy: {
        name: "Legacy",
        description: "No type field",
        path: "legacy/skills",
        skills: {
          old: "old-skill",
        },
      },
    },
  };

  it("separates skills from agents", () => {
    const result = resolveIncludes(
      ["development/architecture", "agents/nextjs"],
      registry,
    );
    assert.equal(result.skills.length, 1);
    assert.equal(result.agents.length, 1);
    assert.equal(result.skills[0].key, "development/architecture");
    assert.equal(result.agents[0].key, "agents/nextjs");
  });

  it("resolves correct source paths", () => {
    const result = resolveIncludes(["development/git"], registry);
    assert.equal(result.skills[0].srcPath, path.join("development/skills", "02-git"));
    assert.equal(result.skills[0].destFolder, "02-git");
  });

  it("treats categories without type as skills", () => {
    const result = resolveIncludes(["legacy/old"], registry);
    assert.equal(result.skills.length, 1);
    assert.equal(result.agents.length, 0);
  });

  it("skips unknown categories", () => {
    const result = resolveIncludes(["nonexistent/foo"], registry);
    assert.equal(result.skills.length, 0);
    assert.equal(result.agents.length, 0);
  });

  it("skips unknown skill keys", () => {
    const result = resolveIncludes(["development/nonexistent"], registry);
    assert.equal(result.skills.length, 0);
  });

  it("handles empty include list", () => {
    const result = resolveIncludes([], registry);
    assert.equal(result.skills.length, 0);
    assert.equal(result.agents.length, 0);
  });

  it("handles multiple entries from same category", () => {
    const result = resolveIncludes(
      ["development/architecture", "development/git"],
      registry,
    );
    assert.equal(result.skills.length, 2);
  });
});

// ─── findAgentFile ───────────────────────────────────────────────────────────

describe("findAgentFile", () => {
  let tmpDir: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "agent-test-"));
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("returns null for non-existent directory", () => {
    assert.equal(findAgentFile("/nonexistent/path"), null);
  });

  it("finds agent.md as the primary file", () => {
    fs.writeFileSync(path.join(tmpDir, "agent.md"), "# Agent");
    fs.writeFileSync(path.join(tmpDir, "other.md"), "# Other");

    const result = findAgentFile(tmpDir);
    assert.equal(result, path.join(tmpDir, "agent.md"));
  });

  it("falls back to first .md file when no agent.md", () => {
    fs.writeFileSync(path.join(tmpDir, "instructions.md"), "# Instructions");

    const result = findAgentFile(tmpDir);
    assert.equal(result, path.join(tmpDir, "instructions.md"));
  });

  it("returns null for empty directory", () => {
    assert.equal(findAgentFile(tmpDir), null);
  });

  it("returns null for directory with no .md files", () => {
    fs.writeFileSync(path.join(tmpDir, "readme.txt"), "text file");

    assert.equal(findAgentFile(tmpDir), null);
  });
});

// ─── findSkillFile ────────────────────────────────────────────────────────────

describe("findSkillFile", () => {
  let tmpDir: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "skill-test-"));
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("returns null for non-existent directory", () => {
    assert.equal(findSkillFile("/nonexistent/path"), null);
  });

  it("finds skill.md as the primary file", () => {
    fs.writeFileSync(path.join(tmpDir, "skill.md"), "# Skill");
    fs.writeFileSync(path.join(tmpDir, "other.md"), "# Other");

    const result = findSkillFile(tmpDir);
    assert.equal(result, path.join(tmpDir, "skill.md"));
  });

  it("falls back to first .md file when no skill.md", () => {
    fs.writeFileSync(path.join(tmpDir, "content.md"), "# Content");

    const result = findSkillFile(tmpDir);
    assert.equal(result, path.join(tmpDir, "content.md"));
  });

  it("returns null for empty directory", () => {
    assert.equal(findSkillFile(tmpDir), null);
  });

  it("returns null for directory with no .md files", () => {
    fs.writeFileSync(path.join(tmpDir, "readme.txt"), "text file");

    assert.equal(findSkillFile(tmpDir), null);
  });
});

// ─── hasDifferences ──────────────────────────────────────────────────────────

describe("hasDifferences", () => {
  let tmpDir: string;
  let srcDir: string;
  let destDir: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "agent-diff-"));
    srcDir = path.join(tmpDir, "src");
    destDir = path.join(tmpDir, "dest");
    fs.mkdirSync(srcDir, { recursive: true });
    fs.mkdirSync(destDir, { recursive: true });
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("returns true when dest does not exist", () => {
    fs.writeFileSync(path.join(srcDir, "file.txt"), "hello");
    assert.equal(hasDifferences(srcDir, path.join(tmpDir, "nonexistent")), true);
  });

  it("returns false for identical directories", () => {
    fs.writeFileSync(path.join(srcDir, "file.txt"), "hello");
    fs.writeFileSync(path.join(destDir, "file.txt"), "hello");
    assert.equal(hasDifferences(srcDir, destDir), false);
  });

  it("returns true when file contents differ", () => {
    fs.writeFileSync(path.join(srcDir, "file.txt"), "hello");
    fs.writeFileSync(path.join(destDir, "file.txt"), "world");
    assert.equal(hasDifferences(srcDir, destDir), true);
  });

  it("returns true when src has a new file", () => {
    fs.writeFileSync(path.join(srcDir, "a.txt"), "a");
    fs.writeFileSync(path.join(srcDir, "b.txt"), "b");
    fs.writeFileSync(path.join(destDir, "a.txt"), "a");
    assert.equal(hasDifferences(srcDir, destDir), true);
  });

  it("handles nested directories", () => {
    const srcSub = path.join(srcDir, "sub");
    const destSub = path.join(destDir, "sub");
    fs.mkdirSync(srcSub);
    fs.mkdirSync(destSub);
    fs.writeFileSync(path.join(srcSub, "nested.txt"), "same");
    fs.writeFileSync(path.join(destSub, "nested.txt"), "same");
    assert.equal(hasDifferences(srcDir, destDir), false);
  });

  it("detects differences in nested directories", () => {
    const srcSub = path.join(srcDir, "sub");
    const destSub = path.join(destDir, "sub");
    fs.mkdirSync(srcSub);
    fs.mkdirSync(destSub);
    fs.writeFileSync(path.join(srcSub, "nested.txt"), "old");
    fs.writeFileSync(path.join(destSub, "nested.txt"), "new");
    assert.equal(hasDifferences(srcDir, destDir), true);
  });

  it("returns false for two empty directories", () => {
    assert.equal(hasDifferences(srcDir, destDir), false);
  });
});

// ─── findMissingGitignoreEntries ─────────────────────────────────────────────

describe("findMissingGitignoreEntries", () => {
  it("returns all paths when no .gitignore exists", () => {
    const result = findMissingGitignoreEntries([".agent", "agent.md"], null);
    assert.deepEqual(result, [".agent", "agent.md"]);
  });

  it("returns empty when all paths are ignored", () => {
    const gitignore = ".agent\nagent.md\n";
    const result = findMissingGitignoreEntries([".agent", "agent.md"], gitignore);
    assert.deepEqual(result, []);
  });

  it("returns only the missing paths", () => {
    const gitignore = ".agent\n";
    const result = findMissingGitignoreEntries([".agent", "agent.md"], gitignore);
    assert.deepEqual(result, ["agent.md"]);
  });

  it("ignores comment lines", () => {
    const gitignore = "# .agent\n";
    const result = findMissingGitignoreEntries([".agent"], gitignore);
    assert.deepEqual(result, [".agent"]);
  });

  it("ignores empty lines", () => {
    const gitignore = "\n\n.agent\n\n";
    const result = findMissingGitignoreEntries([".agent"], gitignore);
    assert.deepEqual(result, []);
  });

  it("matches paths with leading slash in .gitignore", () => {
    const gitignore = "/.agent\n";
    const result = findMissingGitignoreEntries([".agent"], gitignore);
    assert.deepEqual(result, []);
  });

  it("matches paths with trailing slash in .gitignore", () => {
    const gitignore = ".agent/\n";
    const result = findMissingGitignoreEntries([".agent"], gitignore);
    assert.deepEqual(result, []);
  });

  it("strips ./ prefix from input paths", () => {
    const result = findMissingGitignoreEntries(["./.agent"], null);
    assert.deepEqual(result, [".agent"]);
  });

  it("handles nested paths like .github/copilot-instructions.md", () => {
    const gitignore = ".github/copilot-instructions.md\n";
    const result = findMissingGitignoreEntries(
      [".github/copilot-instructions.md"],
      gitignore,
    );
    assert.deepEqual(result, []);
  });
});

// ─── generateSkillsIndexContent ──────────────────────────────────────────────

describe("generateSkillsIndexContent", () => {
  it("generates header", () => {
    const result = generateSkillsIndexContent([]);
    assert.ok(result.includes("# Installed Skills"));
    assert.ok(result.includes("Auto-generated"));
  });

  it("groups entries by category", () => {
    const entries = [
      { key: "dev/arch", srcPath: "dev/skills/01-arch", destFolder: "01-arch" },
      { key: "dev/git", srcPath: "dev/skills/02-git", destFolder: "02-git" },
      { key: "frontend/components", srcPath: "fe/skills/01-comp", destFolder: "01-comp" },
    ];
    const result = generateSkillsIndexContent(entries);
    assert.ok(result.includes("## dev"));
    assert.ok(result.includes("## frontend"));
    assert.ok(result.includes("- [01-arch](./01-arch/skill.md)"));
    assert.ok(result.includes("- [02-git](./02-git/skill.md)"));
    assert.ok(result.includes("- [01-comp](./01-comp/skill.md)"));
  });

  it("returns just header for empty list", () => {
    const result = generateSkillsIndexContent([]);
    assert.ok(!result.includes("##"));
  });
});
